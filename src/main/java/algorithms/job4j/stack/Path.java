package algorithms.job4j.stack;

import java.util.Stack;

/**
 * Дана входная строка отображающая путь в файловой системе типа Unix.
 *
 * Решение этой задачи сводится к следующим шагам:
 *  1. Разбить входную строку по символу "/".
 *  2. Полученный список вставлять по элементам в Stack.
 *  3. Если элемент пустой или равен ".", то пропускаем его.
 *  4. Если элемент равен "..", то удаляем один элемент из Stack,
 *  5. Когда все элементы пройдены, то нужно преобразовать Stack в строку.
 *
 *
 *  Давайте разберем путь /a/./b/../../c/ по частям:
 *
 *  Разделение: ["", "a", ".", "b", "..", "..", "c", ""]
 *
 * 1. /a/ - это начальная директория, которая называется a.
 * 2. . - этот символ обозначает текущую директорию. В данном случае это директория a.
 * 3. /b/ - это подкаталог внутри директории a. Таким образом, на этом этапе путь указывает на директорию /a/b/.
 * 4. .. - этот символ обозначает родительскую директорию. Поскольку мы находимся в /a/b/, переход к родительской директории вернет нас в /a/.
 * 5. .. - снова обозначает переход к родительской директории, что приведет нас к /, так как /a/ является дочерней директорией корневой директории.
 * 6. /c/ - это указание на директорию c, которая находится в корневой директории.
 * Таким образом, полный путь /a/./b/../../c/ в конечном итоге указывает на директорию /c.
 */
public class Path {
    public static String simplify(String path) {
        var stack = new Stack<>();
        var components = path.split("/");
        for (var component : components) {
            if (component.equals("..")) {
                stack.pop();
            } else if (!component.isEmpty() && !component.equals(".")) {
                stack.push(component);
            }
        }
        var result = new StringBuilder();
        for (Object dir : stack) {
            result.append("/").append(dir);
        }
        return !result.isEmpty() ? result.toString() : "/";
    }

    public static void main(String[] args) {
        System.out.println(simplify("/a/./b/../../c/"));
    }
}
